# Application Server

---

## History
> first commit
>> WebConfig와 각 controller, 전체적인 view 파일만 생성하고 커밋.
>
> #
>> 23/02/10
>>> WebClient로 api Server로 데이터 요청 처리 구현.
> 
>> 23/02/11 ~ 23/02/28
>>> SpringSecurity 단일로 api에서 인증 인가 처리가 이해가 안되는 문제로 SpringSecurity + JWT 로 전환.   
>>> SpringSecurity에서 /login 요청을 가로채 처리하도록 AuthenticationFilter를 구현했으나   
>>> Client Server로 토큰을 리턴하도록 하는 방법을 찾지 못해   
>>> 로그인 요청을 /member/login 으로 받아 member 서비스단에서 직접 처리한 후 토큰 생성하고 토큰을 리턴하도록 구현.   
>>> 그로 인해 AuthenticationFilter가 불필요해져 삭제 예정.
>>> AccessToken(At)과 RefreshToken(Rt) 두가지 토큰을 생성하고 처리하도록 구현.   
>>> At은 1시간의 만료기간. Rt은 2주의 만료기간을 설정.   
>>> At가 만료되어 Rt를 통해 재발급을 받는 경우 Rt 역시 재발급 받도록 구현.   
>>> Rt는 DB에 저장하고 At, Rt 모두 Client Server에 리턴해 Client에서는 쿠키에 두가지 토큰을 보관.   
>>> localStorage에 보관하지 않은 이유로는 XSS 공격을 방어하기 위해서이며 Cookie에서 발생할 수 있는 문제인 csrf 공격을 막기 위해   
>>> Client Server에서 쿠키 생성 시 HttpOnly, Secure, same-site를 설정.   
>>> 또한 인터셉터에서 referer를 체크하도록 해 혹시나 뚫고 들어오더라도 한번 더 체크해 방지할 수 있도록 구현 필요.
>>> At Cookie의 경우 만료 시간이 1분 작게 설정.   
>>> Api Server에 요청하는 시점이 토큰 만료시점과 겹치는 경우 문제가 발생할 수 있기 때문에 Client에서 사전에 처리할 수 있도록 하기 위함.   
>>> 아직 부족해서 처리하지 못한점이 XSS 방지.   
>>> XSS의 경우 HttpOnly로 다 막을수는 있다고 하지만 마냥 안심할 수 없는 부분이 만약 내 도메인 내의 게시글에 스크립트를 삽입하는 경우   
>>> same-site 설정과 referer를 뚫고 들어올 수 있다고 판단해 게시글에 스크립트 삽입이 불가하도록 설정해야할 필요성이 있다고 생각함.   
>>> 이건 꼭 학습해서 처리해야 하는 부분.
>
>> 23/03/01 ~ 23/03/03
>>> TokenInterceptor로 referer 체크하도록 일단 추가만 처리.   
>>> interceptor 처리와 여기서 발생하는 Exception 처리는 모든 구현이 끝난 후에 마지막에 구현.   
>>> 초기 기능 구현 당시 At 하나만 갖고 있도록 구현했기 때문에 해당 부분들 Rt를 같이 갖고 있도록 수정.   
>>> At가 만료된 경우 Rt를 Api Server에 보내 재발급 받은 후 데이터 요청을 하도록 수정.
> 
>> 23/03/06 ~ 23/03/07 
>>> api 서버의 AuthorizationFilter에서 TokenProvider에 접근하지 못하는 문제 발생.
>>> nullpointerException이 발생했는데 Filter의 constructor에 TokenProvider를 추가해주고
>>> 필터를 등록해둔 SecurityConfig에도 같이 추가해줌으로써 해결.
>>> 당연히 @Component 달고 @Autowired를 달아주면 주입이 될거라고 생각을 했으나 전혀 주입 받지 못하는 상태였던 것.
>>> 이런 경우에는 생성자를 통한 주입으로 처리를 해야 정상적으로 동작한다.
>>>
>>> 사용자 로그인 정보 처리 구현.
>>> 계속 고민했으나 로그인 여부는 RefreshToken을 localStorage에 넣어두고 이 토큰 소지 여부로 파악 할 수 있다고 쳐도
>>> 게시판 상세페이지같은 곳에서 작성자와 사용자 아이디를 비교하는 경우에는 이 방법이 불가하다고 판단 함.
>>> 그래서 api에서 데이터를 받을 때 게시글 데이터와 사용자의 아이디를 같이 받는 형태로 구현.
>>> 클라이언트 서버에서는 세션을 전혀 사용하지 않고 있고 api 서버에서 그나마 권한관리로 인해 세션을 사용중인데   
>>> 이 문제점이 딱히 검색해서도 나오는 방법이 없었고 생각해본 방법은 세가지.
>>>> 1. Spring Security를 사용중이니 클라이언트 서버에 세션을 만들어 사용자 정보(아이디, 닉네임 정도)를 관리.
>>>> 2. api 서버에서 요청 데이터를 리턴할 때 사용자 아이디를 같이 리턴.
>>>> 3. 2번 처럼 처리하는데 리턴할 때 사용자 아이디를 리턴하는 것이 아닌 작성자와 사용자 아이디가 동일한지 api 서버가 체크 후 boolean으로 리턴   
>>>
>>> 여기서 2번 방법을 선택한 이유   
>>> 1번은 stateless여야 한다는 개념에서 벗어나기 때문이다. 물론 api 서버에서도 권한관리를 편하게 하기 위해 세션을 사용하고 있지만   
>>> 클라이언트 서버와 api 서버 모두 세션을 사용하면서 처리한다는 점에서 stateless로 처리하는것이 무의미 해진다고 생각을 했고
>>> 두 서버 모두 세션으로 인한 부담이 증가할 것이라고 생각했기 때문이다.   
>>> api에서의 권한관리를 위한 세션 활용도 개발 편의성은 높여주지만 아무래도 그에 따른 부담이 있다고 생각하고   
>>> 이걸 개선하기 위해서는 토큰에 권한 정보가 들어가거나, 아니면 토큰 검증 후 토큰의 사용자 아이디를 통해 권한을 체크해주는   
>>> 방법으로 개선이 가능할것으로 보이나 코드를 어떻게 작성하는지에 따라 다르겠지만 오히려 비 효율적일 수도 있다는 생각이 듦.   
>>> 예를 들어 메인 페이지를 제외한 모든 페이지에서 로그인이 필요하고 권한에 따라 출력되는 데이터가 달라지는 페이지라면.   
>>> 매 요청 시 마다 권한 확인을 위한 DB 접근과 코드의 처리가 필요하게 될것이고 그 후에 권한 체크를 해 리턴하는 방식이기 때문에   
>>> 세션 메모리에 대한 부담이 적어지기만 할 뿐 오히려 처리 속도에 있어서는 어떨지가 중점이라고 생각.
>>>
>>> 3번 방법을 사용하지 않는 이유는 상세페이지 데이터의 경우 하나의 row가 리턴되지만 그 페이지의 댓글의 경우는
>>> 리스트 형태로 리턴될건데 그 리스트의 모든 경우에 대해 api 서버에서 boolean으로 하나하나 다 대조해서 매핑한 뒤 보내는 것은   
>>> 아무래도 비효율적이다. 라는 생각을 했기 때문.   
>>> 그래서 사용자 아이디를 리턴해 처리하게 되면 상세페이지의 경우 프론트에서 eq로 비교해 출력해야해서 코드가 아주 살짝 길어지지만
>>> 반대로 comment에서는 api서버에서 처리도 덜해서 보내줄 수 있고 어차피 프론트에서는 json으로 받아 출력하도록 할것이기 때문에
>>> 이때 처리하는 것이 좀 더 빠르게 처리할 수 있겠다 라고 생각했기 때문.
> 
>> 23/03/08 ~ 23/03/15
>>> 계층형 게시판 전체 구현 완료.   
>>> 로그인 여부는 lsc라는 무작위 값을 갖고 있는 쿠키를 통해 처리.
>>> lsc 쿠키는 랜덤값을 갖고 있기 때문에 아무런 의미도 갖지 않는 쿠키이고 RefreshToken을 쿠키에 담을 때 같이 담아주게 된다.
>>> 주기 역시 refreshToken과 같은 주기를 갖게 되고 refreshToken이 갱신될때 lsc 역시 갱신된다.
>>> 이 lsc 쿠키는 아무런 값을 갖지 않기 때문에 노출이 되어도 상관이 없다고 판단했고 이 쿠키가 존재한다는 것은 RefreshToken이 존재한다는 것과 같은 의미이기 때문에   
>>> 클라이언트에서 접근할 수 있어야 하기 때문에 httpOnly 설정은 하지 않음.   
>>> jquery로 페이지 로딩 직후 lsc 쿠키 존재 여부에 따라 로그인 또는 로그아웃을 출력하도록 하는 방법으로 구현.   
>>> 그렇기 때문에 사용자가 로그아웃을 요청하는 경우 모든 토큰의 쿠키를 제거하면서 lsc 쿠키 역시 제거해야 함.   
> 
>>> 토큰의 갱신은 AccessToken과 RefreshToken을 쿠키에 HttpOnly, secure, same-site 설정으로 보안을 해두었고      
>>> 아직 구현하지 않은 인터셉터에서의 referer 체크로 csrf까지 대비할 예정.   
>>> AccessToken은 1시간 RefreshToken은 2주의 만료기간을 갖는데 만료시간에 가까워지는 경우 발생할 수 있는 오류를 피하기 위해 AccessToken 쿠키는 59분으로 설정.   
>>> 권한이 필요하지 않은 각 게시판 리스트와 로그인, 회원가입 페이지를 제외하고 나머지 요청에 대해서는 쿠키 존재여부를 체크하도록 구현.   
>>> 위 페이지 외에 각 게시판 상세페이지의 경우도 권한은 딱히 필요하지 않지만 refreshToken이 존재한다거나 로그인 되어 있는 상태라면 작성자와 사용자 아이디를 비교해   
>>> 게시글 수정, 삭제 기능을 사용할 수 있도록 해야 하기 때문에 토큰이 아예 존재하지 않는 경우와 그렇지 않은 경우를 구분해 처리하도록 구현.   
> 
>>> 게시글 수정의 경우 페이지 요청 시 해당 게시글 데이터를 가져올 때 작성자와 사용자의 아이디를 비교해 동일하면 데이터를 리턴하도록 구현.   
>>> 게시글 답글의 경우는 이전 프로젝트들에서는 해당 게시글의 groupNo, indent, UpperNo를 받아와 페이지를 출력해주고 작성 요청 시 이 데이터를 수정해   
>>> 등록해주는 형태로 구현했는데 이번에는 굳이 api 서버에 요청을 보내 데이터를 받아온 뒤 작성 요청을 다시 보내는것 보다 한번만 요청해서 처리하는 것이 좋겠다는 판단을 해서   
>>> 페이지 요청시에는 클라이언트 서버에 요청을 하며 보낸 boardNo만 그대로 넘기면서 페이지를 출력하도록 구현 했음.   
>>> 이유는 이렇게 분리된 restfulAPI 서버라면 여러 클라이언트 서버에서 다양한 요청이 올텐데 이 요청의 횟수를 줄이는 것이 성능 개선에 조금이라도 도움이 될것으로 생각했기 때문.   
>>> 답글의 경우 어차피 작성하는데에 있어서 상위글의 boardNo만 존재하면 되기 때문에 클라이언트 서버내에서 해결하도록 하고   
>>> 작성 요청시 제목, 내용, 글번호를 담아 api 서버에 요청하면 api 서버에서는 그때 해당 게시글의 groupNo, indent, upperNo를 가져오고 그 데이터를 수정해 바로   
>>> insert 요청을 수행해 주면 된다고 생각했기 때문에 이와 같은 방법으로 구현.
> 
>>> 현재 좀 신경쓰이는 문제가 토큰 체크 방법.   
>>> 지금은 각 요청에 따라 해당 메소드를 호출해 체크를 하도록 구현했는데 이걸 굳이 메소드 작성시에 호출하지 않아도 알아서 동작하게 할 방법이 없을까 고민중.   
>>> 인터셉터에 넣을까도 고민했지만 그렇게 하는 경우 현재 구현된 틀에서는 재발급 받아온 쿠키를 꺼낼 방법이 없음.   
>>> 굳이 인터셉터에 넣는다면 ajax를 통해 매 요청마다 토큰체크를 하도록 하는 방법이 있지 않나? 라는 생각도 했지만 그럴거면 그냥 컨트롤러에 메소드 하나 만들지
>>> 굳이 인터셉터를 만들어서 처리할 필요는 없다고 생각함.   
>>> 근데 체크하는 메소드 하나 호출하면 체크에 재발급 까지 다 해서 리턴하도록 만들어놨다고는 해도 매 요청마다 메소드 호출하는 코드를 넣어야 하고
>>> 하나 빼먹으면 api 에서 바로 403 날라오니까 이건 개선할 필요가 있다고 생각함. 인터셉터에서 원하는 타입으로 리턴하는 방법을 찾아보는것도 방법이 될 것 같음.
> 
>>> 초반 rest api 계획에서는 계층형 게시판은 webClient로 처리, 이미지 게시판은 restTemplate으로, 댓글은 자바 connection으로 처리하려고 했으나
>>> 계층형 게시판을 webClient로 처리하다보니 다양한 문제가 생기는것을 확인했고 그래서 전체 다 webClient로 구현.
>>> 그 후에 restTemplate, java connection으로 전체 다 구현해보는 방법으로 변경.
>>> 그래서 connection 패키지에 javaCon, restTemplate, webClient 라는 하위 패키지 생성 후
>>> 각 패키지에서 게시판별 클래스로 분리.
> 
> 
>> 23/03/16 ~ 23/03/17
>>> comment 출력 기능 완료.
>>> ImageBoard는 아직 미구현이라 comment 적용하지 않았으나 comment.html로 분리해서 추가만 해주면 되기 때문에 문제는 발생하지 않을것으로 생각.
>>> 또한 comment 데이터를 요청하는 형태 역시 동일하기 때문에 큰 문제는 발생하지 않을 것으로 보임.
>
>>> comment의 경우 게시판 상세페이지 로딩 후 JQuery에서 comment 데이터를 요청하고 가져온 데이터를 파싱해서 처리.
>>> 중간에 JSON Array 파싱에 대해 문제가 발생했으나 해결.
>>> 이전 프로젝트들에서 경험한 형태와 다른 형태의 json이었으나 동일하게 처리하려다 보니 발생한 문제.
>>> 이전에는 딱 하나의 DTO의 리스트만 리턴받았기 때문에 바로 each를 돌려 처리가 가능했지만,   
>>> 이번에는 json 배열이 아닌 하나의 JSON 안에 comment 데이터가 배열로 들어가 있는 상태였기 때문에 바로 each문으로 풀려고 해도 풀리지 않았던 것.
>>> 이 문제는 client server README에 메모로 정리했으며 블로그에도 기록할 예정.
>
>>> comment의 페이징 기능까지 처리 완료했으며 남은건 comment reply와 delete 기능.
>>> 이 두가지 기능 모두 ajax로 비동기처리로 진행 예정.
> 
>>> comment와 계층형 게시판의 페이징에서 active 상태인 a 태그를 bold에 black 컬러로 출력되도록 수정.
>>> 계층형 게시판 페이징의 경우 태그가 html 파일에 그대로 작성되어 있었기 때문에 style 태그를 통해 처리가 가능했으나
>>> comment의 경우 jquery에서 태그를 만들어 추가하는 형태이다보니 css에서 해당 태그를 잡지 못하는 것으로 보임.
>>> 그래서 comment는 페이징 영역 생성 시 active 상태인 a 태그에 style 속성을 넣어 만들어주는 형태로 처리.
> 
>>> 계층형 게시판 페이징에서 다른 페이지로 이동하기 위해 버튼을 눌렀을 때 keyword가 null이 아닌 blank 상태로 넘어가
>>> webClient로 보내줄 때 오류가 발생.
>>> 그래서 조건문에 keyword.equals("") 조건을 추가해 문제 해결.
> 

## 메모
> restAPI 에 연결하는 방법으로는 아래의 방법들이 존재.
> 1. WebClient
> 2. Java(HttpURLConnection)
> 3. RestTemplate(spring)
> 하지만 RestTemplate는 spring5부터 Deprecated 상태.   
> 버전에 따라 사용하게 되는 경우가 있을 수 있으니 아래처럼 분리해서 사용.
>> 1. WebClient -> HierarchicalBoard
>> 2. Java -> ImageBoard
>> 3. Comment, Member -> RestTemplate
>> 
> 
> interceptor 구현해서 referer 체크 할 수 있도록.   
> 단, get 요청이면서 단순 페이지 데이터만 나오는 요청들은 제외   
> 인터셉터 제외 페이지 리스트
> 1. boardList
> 2. boardDetail
> 3. imageList
> 4. imageDetail
> 5. loginForm
> 6. join
> 7. commentList(hierarchical & image)
> 
> 두 게시판 게시글 작성 시 xss 대비 방안 세워서 처리.   
> 
> 전체적인 구현 이후 TokenInterceptor 통해서 referer 체크 마저 구현하고 ExceptionHandling까지 처리.
> 
> interceptor
>> referer 체크 후 토큰 체크하도록 하면
>> rt, at가 null일때는 login 페이지로 가도록 하고
>> rt만 존재할때는 reissued를 받게 하면 요청마다 토큰 체크를 하도록 할 필요가 없을듯.
>> 그럼 interceptor를 거치지 않는 페이지 리스트에서 각 게시판 detail 페이지는 있으면 안된다.
>> 여기서 문제점. response.addCookie로 재발급된 토큰을 저장할건데.
>> 이게 response가 완전하게 전달되지 않은 상태에서 새로 발급 받은 토큰을 어떻게 요청할것이며
>> 이 요청에서 토큰이 재발급이 되었는지 여부는 어떻게 확인할것인지가 관건.
>> 만약 인터셉터에서 null 여부만 체크해 처리하게 되면 사실상 인터셉터를 거치는 모든 페이지는 권한이 필요한 페이지 이므로 
>> null일 경우 로그인 페이지로 리다이렉트 하면 되긴 하지만
>> 각 게시판 Detail 페이지의 경우 그럼 한번 더 토큰 여부를 검증해야 하는 문제가 발생.
>> 인터셉터에서 토큰 존재 여부를 체크하지 않는다면 토큰 서비스로 분리해두긴 했지만 모든 요청에서 해당 서비스를 호출해 체크하도록 해야한다.
> 
> 토큰 여부 체크 과정
>> at, rt 모두 존재하는지 rt만 존재하는지 둘다 존재하지 않는지를 체크.
>> at가 존재한다면 클라이언트의 요청을 수행
>> rt만 존재한다면 토큰 재발급 후 재발급 받은 at로 요청 수행
>> 둘다 존재하지 않는다면 로그인 페이지로 redirect
>> at가 존재한다는 경우는 고려해야할 사항이 없음. 그대로 cookie로 꺼내 전송하면 되기 때문.
>> 둘다 존재하지 않는 경우도 로그인 페이지로 리다이렉트 해주거나 권한이 필요 없는 페이지는 요청을 수행하면 되기 때문에 고려사항이 없음.
>> rt만 존재하는 경우는 재발급 요청 -> 리턴된 rt, at 쿠키에 저장 -> at 리턴 -> 리턴받은 at로 요청 수행 이 순서로 진행되어야 하는데
>> 분리된 과정을 하나의 메소드로 묶어서 그 메소드에서 각각 호출해 처리하도록 하기에는 리턴되는 타입들의 차이가 발생.
>> 그럼 리턴되는 타입을 하나로 통일시켜 처리하거나 묶지 못하고 매 요청시마다 각각 호출해 사용하는 방법으로 처리해야 함.
>> 재발급 된 토큰은 JwtDTO 타입으로 리턴될것. at가 존재하는 경우도 JwtDTO에 담아 리턴이 가능. 없는 경우는 그럼 그냥 null을 리턴?
>> 이 방법의 부작용은 기껏 checkExistsToken으로 cookie를 털어 체크했는데 DTO에 담겨 왔다는 이유로 한번 더 체크해야하는 문제가 발생.
>> 그럼 어차피 리턴받은 시점에 또 다시 dto 값을 체크해 그에 맞는 조건으로 수행하도록 해야함.
>> 그래도 한가지 조건이 줄어드는 장점이 있음.
>> null이 아니라면 재발급 받은 토큰이 DTO에 들어가있거나 존재하던 쿠키값이 DTO에 들어가서 리턴될것이므로 
>> dto가 null이면 로그인페이지로 리다이렉트. 그게 아니라면 요청을 수행하도록 할 수는 있음.
>> 그럼 모든 요청에서 JwtDTO 타입으로 체크 메소드를 호출하고 그 체크메소드에서는 존재 여부 체크 후 DTO에 값을 담거나 null을 리턴하도록 하면.
>> 리턴되는 dto를 통해 그에 맞는 조건을 수행할 수 있게 됨.
> 로직 정리
>> 1. at 존재
>>> client request -> existsToken -> checkExistsToken -> dto.setAt -> return to clientServer -> api server request
>> 2. token 재발급
>>> client request -> existsToken -> checkExistsToken -> reissuedToken -> savedToken -> dto.setAt -> return to clientServer -> api serverRequest
>> 3. token null
>>> client request -> existsToken -> checkExistsToken -> return to clientServer(null) -> redirect loginForm
>> 간단하게 코드 정리
>>> ``` java
>>> @PostMapping("/")
>>> public String requestController(HttpServletRequest request) {
>>>     JwtDTO dto = tokenService.existsToken(request);
>>>     if(dto == null)
>>>         return "th/member/loginForm";
>>>     
>>>     0000service.insert(request, dto);
>>>     
>>>     return "0000";
>>> }
>>> 
>>> @Override
>>> public JwtDTO existsToken(HttpServletRequest request){
>>>     Cookie at = ...;
>>>     Cookie rt = ...;
>>> 
>>>     if(at == null && rt == null)
>>>         return null;
>>>     else if(at != null && rt != null)
>>>         return JwtDTO.builder()
>>>                 .accessHeader(at.getName())
>>>                 .accessValue(at.getValue())
>>>                 .build();
>>>     else if(at == null && rt != null)
>>>         return reissuedToken(request);
>>> }
>>> ```
>> 다른 문제점.
>> refreshToken을 cookie에 담아둔다면 로그인 여부 체크를 어떻게 할지.
>> 아무생각없이 rt가 localStorage에 존재하면 로그인 한것으로 간주하려고 했으나
>> 둘다 cookie에 저장하는 경우에는 httpOnly 설정으로 클라이언트에서 접근할 수 없을건데 뭘로 검증할것인가가 관건.
>> 그럼 그나마 떠오르는 방법이 api server에서 모든 요청에 principal 을 체크해 리턴해주는 방법이 있음.
>> 토큰이 존재하면 AuthorizationFilter에서 contextHolder에 저장하도록 되어있기 때문에 principal을 통해 로그인한 사용자 아이디 리턴이 가능함.
>> 그럼 여기서 고민해야 할 사항.
>> 사용자 아이디를 리턴할 것인가. 아니면 boolean으로 로그인 여부만 리턴할 것인가.
>> 사용자 아이디가 직접적으로 필요한 페이지는 작성자와 사용자를 구분해야 하는 각 게시판 detail 페이지와 댓글 데이터 정도이다.
>> boolean으로 리턴하게 되면 로그인 여부는 쉽게 처리할 수 있지만 작성자와 구분이 어려워진다.
>> 모든 요청에서 아이디를 리턴하는 것은 정보 유출이 되지 않을까 생각했지만. 생각해보니까 어차피 아이디 알아내는것 정도는 매우 쉽다.
>> 어차피 왠만한 페이지에서 글 남기면 출력되는게 아이디 혹은 닉네임인데 닉네임만 눌러도 아이디가 출력되는 페이지도 많기 때문.
>> 또한 아이디는 알아낸다고 해도 중요정보인 사용자 실명이나 비밀번호, 그 외 주소등 개인정보가 같이 딸려오는 것은 아니기 때문에 그걸 같이 보내지만 않으면
>> 아이디를 매번 리턴하는것도 나쁘지 않은 선택으로 보인다.
>> 그렇게 하면 로그인 여부에서도 아이디로 체크하고 한번에 detail 페이지에서 작성자와의 비교역시 가능해지기 때문.
>> 보안에 있어서 주의해야할 점은 사이트에 따라 아이디 혹은 닉네임만 리턴하도록 하고 그 외 정보를 리턴하도록 하지만 않으면 문제는 발생하지 않을것으로 보임.
>> 그럼 rt는 그대로 cookie에 저장하도록 하고 아이디를 리턴받아 로그인 여부와 작성자와의 비교를 처리하는 방법으로 진행.
> 
>> 프로젝트 마무리 하면서 고민해야 할 사항.
>>> 만약 rt를 localStorage에 저장하는 경우 재발급을 받아야 할 때 어떻게 처리할것인가를 고민해야할 필요가 있음.
>>> JQuery를 사용하면 어차피 ajax를 통한 요청이 대다수일텐데 요청을 보낼때 rt만 헤더에 담아 보내면 쿠키에 있는 at는 알아서 넘어갈 것.
>>> 그럼 클라이언트 서버는 requestHeader에서 rt를 꺼내 확인하고 at 역시 꺼내서 확인.
>>> 없으면 재발급 요청할 건데.
>>> 해결 방안. 별거 없었음. response.addHeader에 재발급 받은 rt를 담아 요청 데이터와 같이 리턴해주고 JQuery에서는 데이터 처리 전후 아무때나
>>> localStorage에 rt를 다시 저장하면 된다.
>>> localStorage에 저장하는 방법을 택한다면 클라이언트서버에서 역시 페이지요청과 데이터 요청을 정확하게 분리해서 처리해줘야 한다.
>
>>> 로그인 여부를 cookie로 처리.
>>> 해당 쿠키명은 lsc(login state cookie)로 만들어주고
>>> 이 쿠키는 refreshToken이 발급되는 시점에 같이 생성해서 넘겨준다.
>>> 만료 시점 역시 refreshToken과 동일한 만료 시점을 갖는다.
>>> 그렇기 때문에 refreshToken이 재발급 될 때도 이 쿠키의 만료기간 역시 갱신되어야 한다.
>>> 해당 쿠키는 api 서버로는 넘어가지 않는 쿠키가 될것이고
>>> 아무 의미를 갖지 않는 난수로 만들어진 value를 갖게 될것.
>>> 로그인 상태 표시는 navbar.html로 분리해두었으니 해당 html에서 스크립트를 통해
>>> 해당 쿠키가 존재하기만 하면 로그인을 한 상태라고 인식할 수 있도록 구현한다.
>>> 만약 이 쿠키명으로 인해 로그인 상태에 대해 쿠키를 탈취한 상대가 뭘 하려고 해봤자
>>> 이 쿠키는 단순하게 로그인 & 로그아웃을 표시하기 위한 용도이기 때문에
>>> token값을 갖고 있는 cookie와 문제가 발생할 일도 없을 것.
>>> token 체크는 별도로 클라이언트서버에서 무조건 실행하도록 되어있으니.
>>> 아주 단순하게 버튼 변경에 대한 용도로 사용.
>>> 이걸 원래는 서버에서 model에 담아 넘겨주는 방법을 택하고자 했으나
>>> 그럼 모든 컨트롤러의 페이지 요청에서 이 값을 model에 담아 보내줘야 한다.
>>> 애초에 true, false 체크하는것은 인터셉터한테 맡기면 되니까 그 부분은 문제가 되지 않지만
>>> 모든 페이지 요청에서 이걸 model에 담아주는 경우 누락될 가능성도 존재하기 때문에
>>> security를 사용하는 경우 session을 통해 여부를 확인하듯이 쿠키로 확인하는것이 효율적이라고 생각.
>>> 이렇게 처리하면 쿠키가 탈취되더라도 발생하는 문제는 전혀 없을것이고 로그인 여부를 확인하기 위해
>>> 새로운 요청을 보낼 필요도 없으며 매번 model에 담지 않아도 되기 때문.
> 
>> JQuery에서 JSONArray 파싱하는 문제 해결.
>>> getJSON으로 comment 데이터를 가져와 처리하는 과정에서 문제가 발생.
>>> comment는 페이징 기능까지 들어가야 하기 때문에 JSON 이 좀 복잡하게 온다.
>>> 들어가는 데이터는 api 서버에서 JPA를 사용하기 때문에 Page 타입으로 리턴되는 paging 데이터,
>>> 그리고 comment 데이터의 배열, 로그인한 사용자의 id 이렇게 들어오게 되어 아래처럼 리턴된다.
>>> ``` json
>>> {
>>>     "totalPages" : 2,
>>>     "totalElements" : 31,
>>>     "uid" : "coco",
>>>     "content" : [
>>>         {
>>>             "commentNo" : 49,
>>>             "userId" : "coco",
>>>             "commentDate" : 1671721200000,
>>>             ....
>>>         }
>>>         {
>>>             ....
>>>         }
>>>         ...
>>>     ]
>>> }
>>> ```
>>> 이렇게 리턴되다 보니 단순하게 생각했을 때 result.content.commentNo로 찍으면 바로 나올줄 알았으나 
>>> 바로 undefined.
>>> 그래서 result.uid를 찍어보니 바로 나온다.   
>>> 그럼 json 데이터는 정상적으로 넘어왔다고 볼 수 있다고 생각했고 이것저것 콘솔에 찍어봤지만 모두 허사였다.
>>> 구글링을 통해 JQuery에서 jsonArray parsing을 어떻게 처리하는지 검색해보니
>>> 기존에 하던 방식대로 each를 통해서 처리하는 방법과 for문을 통해 처리하는 방법 두가지가 존재했다.
>>> 근데 each로 처리하는 방법은 제대로 동작하지 않아서 이런 문제가 발생했고, 예제들 json 데이터가
>>> 현재 상황과는 다른 기본 형태의 배열 데이터였기 때문에 문제가 해결되지 않음.
>>> 그래서 for문을 통해 처리하는 방법으로 선택해 처리하게 되었다.
>>> 구글링을 해서 나오는 해결책에 대한 json Array 데이터 구조는 아래와 같다.
>>> ``` json
>>> {
>>>     "commentNo" : 49,
>>>     "userId" : "coco",
>>>     "commentDate" : 1671721200000,
>>>     ....
>>> },
>>> {
>>>     "commentNo" : 50,
>>>     "userId" : "coco",
>>>     "commentDate" : 1671721200000,
>>>     ....
>>> },
>>> ...
>>> ```
>>> 
>>> 내가 기존에 getJSON으로 받아 처리하던 json 데이터구조와 동일하다.
>>> 딱 필요한 데이터의 List를 리턴해주게 되면 이렇게 받을 수 있는데 지금은 
>>> comment 데이터의 리스트 + paging 데이터, 사용자 아이디 이런 조합으로 오다보니까
>>> JSON Array 자체라고 보기에는 어렵고 하나의 json 데이터에 JSON Array가 들어가 있는게 맞다고 봐야될것이라고 생각했다.
>>> 그래서 진행한 테스트가 each문 안에서 for문으로 commentData의 배열을 풀어내는 방법이었다.
>>> 생각했던대로 commentData를 따로 풀어주니 그 안에 있는 배열을 풀어낼 수 있었고 일차원적인 문제 해결은 달성했다.
>>> 하지만. each문이라는게 애초에 그런 반복을 풀어주기 위한 함수인데 단일 json 데이터와 마찬가지인 구조에서
>>> 굳이 each문을 통해 데이터를 풀어내고 그 안에서 또 반복문을 한번 더 사용해 풀어내야 하는가? 라는 문제가 남았다.
>>> 그래서 지금 생각하는 해결 방법으로는 each문을 바로 만들어 풀어내는 것이 아닌 
>>> 페이징, 사용자 아이디 같은 데이터를 먼저 파싱해주고 each 함수를 호출해 처리하는 것은 어떨까? 라는 생각이 듦.
>>> 그럼 불필요하게 두번의 반복문 함수를 호출할 필요도 없고
>>> 코드도 좀 짧아지지 않을까...?
> 
>> 기존 boardProject의 comment 문제점.
>>> 기존에 진행한 프로젝트인 boardProject에서 comment를 분리해 처리하고자 했고
>>> 그렇게 하다보니 JQuery에서 페이지 로딩이 끝나면 데이터를 요청하고 받아와서 파싱을 하도록 해야 했다.
>>> 여기서 발생한 문제가 각 태그들에다가 id 값을 설정하는 바람에 동일한 id 값이 계속 들어갔다는 것.
>>> 이게 동작하는데나 출력하는데 있어서는 문제가 되지 않았지만 애초에 ide에서 그렇게 작성하면 빨간 줄이 생기듯이
>>> 딱히 좋은 방법이라고 생각하기는 어려움.   
>>> 그래서 이 id 값을 다 지우고 class로 수정.
> 
> 
>
>> Exception Hadling 문제점.
>>> client Server 동작중에 발생하는 Exception에 대해서는 @ControllerAdvice를 통해 코드를 작성해주면 해결이 가능.
>>> 하지만 APi Server에서 동작중 발생하는 Exception에 대해서는 client server가 제대로 인식하지 못함.
>>> WebClient를 통해 접근할 때 처리할 수 있는 방법이 retrieve()와 exChange() 두가지가 있는데
>>> 스프링에서는 메모리 누수 우려로 인해 exChange 보다는 retrieve를 사용하는 것을 권장한다고 한다.
>>> 하지만 문제점이 exChange로 하게 되면 api server에 제대로 접근조차 안된다.
>>> 문서에 나와있는 대로 코드를 작성해봐도 접근자체가 되지 않고있고
>>> retrieve로 처리하게 되면 제대로 접근은 하고 있으나 api server에서 강제로 exception을 발생시켜 리턴되는 데이터가 없다보니
>>> client server의 오류인 500에러로 처리해버린다.
>>> @ControllerAdvice 코드들을 다 주석처리하고 넘어오는 상태코드를 확인해보면 제대로 400에러가 넘어오긴 하지만
>>> 핸들링 할 때 이 상태코드로 하는게 아니라 client server에서 발생한 예외처리를 하느라 500 에러로 처리하는 것으로 보인다.
>>>
>>> 또한, Jquery에서 getJSON을 통해 데이터를 요청하는 경우 Exception이 발생하더라도 핸들링에 접근은 하지만 오류 페이지로 이동은 하지 않는다.
>>> 단지 데이터가 null로 넘어가 해당 데이터가 출력이 되지 않을 뿐.
>>> 
>>> 몇가지 테스트를 해보니 retrieve 기준 api 서버에서 responseEntity로 어떤 상태코드를 리턴하는가에 따라 처리가 가능하다.
>>> 하지만 문제점. api server에서 RestControllerAdvice를 구현하더라도 이 exception을 핸들링해서 클라이언트 서버에 리턴을 해주지 못한다.
>>> 이 방법을 찾아야 할것으로 보임.
> 
> 
> file size 오류 해결.
>> 고용량 이미지 파일을 업로드 하고자 하는 경우 SizeLimitExceededException이 발생한다.   
>> 문제는 ajax로 비동기 처리하는 해당 처리에 대해 ExceptionHandler에서 리턴하는 값을 제대로 받지 못한다는 점이다.
>> 문제 해결하는데에 참고한 블로그 url은 아래와 같다.
>> https://velog.io/@tenacity/MultipartException-ExceptionHandler-%EA%B5%AC%ED%98%84-%EC%8B%9C-%EC%A3%BC%EC%9A%94-%EC%84%A4%EC%A0%95-%EC%82%AC%ED%95%AD-SizeLimitExceededException-FileSizeLimitExceededException-MultipartException
>> 해당 블로그에서는 단일 업로드시에는 ExceptionHandler에서 리턴하는 값을 받았지만 다중업로드시처럼 여러번 Exception이 발생하는 경우에는
>> 동작하지 않았다고 한다.
>> 하지만 여기서 이 프로젝트와 차이점은 단일 업로드를 하더라도 Handler에 3번 접근하고 있었다.
>> 확신이 아닌 추측이지만 아마도 컨트롤러에서 데이터를 받을 때 제목, 내용, 이미지 파일 이렇게 받고 있기 때문이 아닌가 싶다.
>> 여튼 문제는 해결이 되었으나
>> 의문점은 아직 남는다.
>> api 서버에서 파일 사이즈 체크를 진행하고 있다.
>> 하지만 어차피 업로드 파일 사이즈가 10MB를 넘어가게 된다면 업로드 자체가 안되도록 yml에 설정이 되어있고,
>> 그럼 api 서버에서 받는 이미지 파일 사이즈는 절대로 10MB를 넘어갈 수 없다는 말이 된다.
>> 그럼 api서버에서는 굳이 파일의 사이즈 체크를 해야할 필요성이 있는가? 에 대한 의문점이 남는다.
>> 이건 차차 고민해보도록 하고
>> 문제를 해결한 방법은 server: tomcat: max-swallow-size: -1 이 설정으로 인해서 해결이 된것인데
>> 이 max-swallow-size가 어떤 것을 의미하는지에 대해 찾아보고 정리를 해야 한다.